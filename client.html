<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tessella</title>
<style>
  /* Local fonts */
  @font-face {
    font-family: 'Space Mono';
    src: url('/fonts/SpaceMono-Regular.woff2') format('woff2');
    font-weight: 400;
    font-style: normal;
  }
  @font-face {
    font-family: 'Space Mono';
    src: url('/fonts/SpaceMono-Bold.woff2') format('woff2');
    font-weight: 700;
    font-style: normal;
  }
  @font-face {
    font-family: 'Playfair Display';
    src: url('/fonts/PlayfairDisplay-Regular.woff2') format('woff2');
    font-weight: 400;
    font-style: normal;
  }
  @font-face {
    font-family: 'Playfair Display';
    src: url('/fonts/PlayfairDisplay-Bold.woff2') format('woff2');
    font-weight: 700;
    font-style: normal;
  }
  @font-face {
    font-family: 'Playfair Display';
    src: url('/fonts/PlayfairDisplay-Black.woff2') format('woff2');
    font-weight: 900;
    font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono';
    src: url('/fonts/JetBrainsMono-Regular.woff2') format('woff2');
    font-weight: 400;
    font-style: normal;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: #0a0a0a;
    color: #ffffff;
    font-family: 'Space Mono', monospace;
    cursor: none;
    user-select: none;
  }

  #canvas {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* --- Idle state: subtle breathing animation --- */
  #idle-indicator {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.7rem;
    color: rgba(255,255,255,0.15);
    letter-spacing: 0.3em;
    text-transform: uppercase;
    animation: breathe 4s ease-in-out infinite;
  }

  #client-id {
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 0.6rem;
    color: rgba(255,255,255,0.08);
    font-family: 'JetBrains Mono', monospace;
  }

  @keyframes breathe {
    0%, 100% { opacity: 0.15; }
    50% { opacity: 0.4; }
  }

  /* --- Content layers --- */
  .content-layer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 40px;
    z-index: 10;
  }

  .content-layer.pos-top { align-items: flex-start; padding-top: 80px; }
  .content-layer.pos-bottom { align-items: flex-end; padding-bottom: 80px; }
  .content-layer.pos-left { justify-content: flex-start; padding-left: 80px; }
  .content-layer.pos-right { justify-content: flex-end; padding-right: 80px; }

  /* --- Text styles --- */
  .display-text {
    font-family: 'Playfair Display', serif;
    text-align: center;
    line-height: 1.3;
    max-width: 90%;
    word-wrap: break-word;
  }

  /* --- Image styles --- */
  .display-image {
    max-width: 90%;
    max-height: 90vh;
    object-fit: contain;
    border-radius: 2px;
  }

  .display-image.fit-cover {
    width: 100%;
    height: 100%;
    object-fit: cover;
    max-width: 100%;
    max-height: 100%;
    border-radius: 0;
  }

  /* Tiled image - shows a portion of a larger image */
  .display-tile {
    position: absolute;
    inset: 0;
    background-repeat: no-repeat;
  }

  /* --- Video styles --- */
  .display-video {
    max-width: 100%;
    max-height: 100vh;
    object-fit: contain;
  }

  .display-video.fit-cover {
    width: 100%;
    height: 100%;
    object-fit: cover;
    max-width: 100%;
    max-height: 100%;
  }

  /* --- Animations --- */

  /* Fade */
  .anim-fade-in {
    animation: fadeIn 1.5s ease-out forwards;
  }
  .anim-fade-out {
    animation: fadeOut 1s ease-in forwards;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
  }
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  /* Slide up */
  .anim-slide-up {
    animation: slideUp 1s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }
  @keyframes slideUp {
    from { opacity: 0; transform: translateY(60px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Typewriter */
  .typewriter-cursor::after {
    content: '▌';
    animation: blink 0.8s step-end infinite;
    color: rgba(255,255,255,0.6);
  }
  @keyframes blink {
    50% { opacity: 0; }
  }

  /* Glitch effect */
  .effect-glitch {
    animation: glitch 0.3s linear infinite;
  }
  @keyframes glitch {
    0% { transform: translate(0); filter: hue-rotate(0deg); }
    20% { transform: translate(-3px, 3px); filter: hue-rotate(90deg); }
    40% { transform: translate(3px, -3px); filter: hue-rotate(180deg); }
    60% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
    80% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
    100% { transform: translate(0); }
  }

  /* Pulse effect */
  .effect-pulse {
    animation: pulse 0.6s ease-in-out 3;
  }
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.08); }
  }

  /* Wave effect */
  .effect-wave .display-text {
    animation: wave 2s ease-in-out;
  }
  @keyframes wave {
    0% { transform: translateY(0) rotate(0deg); }
    25% { transform: translateY(-20px) rotate(-2deg); }
    50% { transform: translateY(0) rotate(0deg); }
    75% { transform: translateY(-10px) rotate(1deg); }
    100% { transform: translateY(0) rotate(0deg); }
  }

  /* Flash effect */
  .effect-flash {
    animation: flash 0.15s linear 3;
  }
  @keyframes flash {
    0%, 100% { background: #0a0a0a; }
    50% { background: #ffffff; }
  }

  /* Noise overlay */
  #noise {
    position: fixed;
    inset: 0;
    z-index: 999;
    pointer-events: none;
    opacity: 0.03;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    background-size: 200px 200px;
  }

  /* Fullscreen prompt */
  #fs-prompt {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    cursor: pointer;
  }
  #fs-prompt span {
    font-size: 1.2rem;
    color: rgba(255,255,255,0.5);
    letter-spacing: 0.2em;
    text-transform: uppercase;
    animation: breathe 2s ease-in-out infinite;
  }
  #fs-prompt.hidden { display: none; }

  /* Connection status */
  #status-dot {
    position: absolute;
    top: 15px;
    left: 20px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #333;
    transition: background 0.5s;
  }
  #status-dot.connected { background: #2ecc40; }
  #status-dot.disconnected { background: #ff4136; }

  /* Eyeball container */
  #eyeball-container {
    position: absolute;
    inset: 0;
    z-index: 5;
    display: none;
  }
  #eyeball-container.active {
    display: block;
  }
</style>
</head>
<body>

<div id="fs-prompt" onclick="goFullscreen()">
  <span>Klick für Vollbild</span>
</div>

<div id="noise"></div>
<div id="status-dot"></div>
<div id="client-id"></div>
<div id="canvas">
  <div id="idle-indicator">bereit</div>
</div>
<div id="eyeball-container"></div>

<script src="/lib/three.min.js"></script>
<script>
// --- Fullscreen ---
function goFullscreen() {
  const el = document.documentElement;
  const rfs = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
  if (rfs) {
    rfs.call(el).catch(() => {});
  }
  // Always dismiss the prompt (iOS doesn't support fullscreen API)
  document.getElementById('fs-prompt').classList.add('hidden');
  // User gesture allows video playback on Android — activate wake lock
  requestWakeLock();
}

// --- WebSocket ---
let ws;
let clientInfo = { id: 0, name: 'Laptop' };
let reconnectTimer;

function connect() {
  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${protocol}//${location.host}?role=client`);

  ws.onopen = () => {
    console.log('Connected');
    document.getElementById('status-dot').className = 'connected';
    if (reconnectTimer) clearInterval(reconnectTimer);
  };

  ws.onclose = () => {
    document.getElementById('status-dot').className = 'disconnected';
    reconnectTimer = setTimeout(connect, 2000);
  };

  ws.onerror = () => ws.close();

  ws.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data);
      handleMessage(msg);
    } catch (e) {
      console.error('Parse error:', e);
    }
  };
}

function handleMessage(msg) {
  switch (msg.type) {
    case 'identity':
      clientInfo = msg;
      document.getElementById('client-id').textContent = `#${msg.id} ${msg.name}`;
      document.title = `Display #${msg.id}`;
      break;

    case 'content-history':
      msg.items.forEach((item, i) => {
        setTimeout(() => handleMessage(item), i * 200);
      });
      break;

    case 'show-text':
      showText(msg);
      break;

    case 'show-image':
      showImage(msg);
      break;

    case 'show-tiled-image':
      showTiledImage(msg);
      break;

    case 'show-video':
      showVideo(msg);
      break;

    case 'video-control':
      controlVideo(msg);
      break;

    case 'show-color':
      document.body.style.background = msg.color;
      break;

    case 'clear':
      clearContent(msg.style);
      break;

    case 'effect':
      applyEffect(msg.effect, msg.duration);
      break;

    case 'show-eyeball':
      showEyeball(msg);
      break;

    case 'eyeball-gaze':
      updateEyeballGaze(msg);
      break;

    case 'hide-eyeball':
      hideEyeball();
      break;

    case 'config-display':
      configureDisplay(msg);
      break;
  }
}

function showText(msg) {
  hideIdle();
  const layer = createLayer(msg.position);
  const el = document.createElement('div');
  el.className = 'display-text';
  el.style.fontSize = msg.fontSize || '2rem';
  el.style.color = msg.color || '#ffffff';

  if (msg.style === 'typewriter') {
    el.classList.add('typewriter-cursor');
    layer.appendChild(el);
    typewriterEffect(el, msg.text, () => {
      el.classList.remove('typewriter-cursor');
    });
  } else if (msg.style === 'slide') {
    el.textContent = msg.text;
    el.classList.add('anim-slide-up');
    layer.appendChild(el);
  } else {
    el.textContent = msg.text;
    el.classList.add('anim-fade-in');
    layer.appendChild(el);
  }

  document.getElementById('canvas').appendChild(layer);
}

function showImage(msg) {
  hideIdle();
  const layer = createLayer(msg.position);
  const img = document.createElement('img');
  img.className = 'display-image anim-fade-in';
  if (msg.fit === 'cover') img.classList.add('fit-cover');
  img.src = msg.url;
  img.onerror = () => {
    // Show error as text
    const errEl = document.createElement('div');
    errEl.className = 'display-text anim-fade-in';
    errEl.style.fontSize = '1rem';
    errEl.style.color = 'rgba(255,100,100,0.5)';
    errEl.textContent = '⚠ Bild nicht ladbar';
    layer.appendChild(errEl);
  };
  layer.appendChild(img);
  document.getElementById('canvas').appendChild(layer);
}

function showTiledImage(msg) {
  hideIdle();
  const { tile, url, style, preserveAspect } = msg;
  const { col, row, cols, rows } = tile;

  if (preserveAspect) {
    // Load image to get dimensions for aspect-ratio-aware tiling
    const img = new Image();
    img.onload = () => {
      const imgRatio = img.naturalWidth / img.naturalHeight;
      const vpRatio = window.innerWidth / window.innerHeight;

      // Calculate scaled size to "cover" the combined display area
      // while maintaining aspect ratio
      let scaledW, scaledH;

      // Try scaling by width first
      scaledW = cols;
      scaledH = cols / imgRatio * vpRatio;

      if (scaledH < rows) {
        // Width scaling doesn't cover height, scale by height instead
        scaledH = rows;
        scaledW = rows * imgRatio / vpRatio;
      }

      // Background size as percentage of viewport
      const bgWidthPct = scaledW * 100;
      const bgHeightPct = scaledH * 100;

      // Center offset (excess on each side)
      const xExcess = scaledW - cols;
      const yExcess = scaledH - rows;

      // This tile's position in the scaled image
      const tileX = xExcess / 2 + col;
      const tileY = yExcess / 2 + row;

      // Convert to background-position percentage
      const xPos = scaledW > 1 ? (tileX / (scaledW - 1)) * 100 : 50;
      const yPos = scaledH > 1 ? (tileY / (scaledH - 1)) * 100 : 50;

      createTileElement(url, bgWidthPct, bgHeightPct, xPos, yPos);
    };
    img.onerror = () => {
      // Fallback to stretch mode on error
      createTileElement(url, cols * 100, rows * 100,
        cols > 1 ? (col / (cols - 1)) * 100 : 0,
        rows > 1 ? (row / (rows - 1)) * 100 : 0
      );
    };
    img.src = url;
  } else {
    // Original stretch behavior
    const bgWidthPct = cols * 100;
    const bgHeightPct = rows * 100;
    const xPos = cols > 1 ? (col / (cols - 1)) * 100 : 0;
    const yPos = rows > 1 ? (row / (rows - 1)) * 100 : 0;
    createTileElement(url, bgWidthPct, bgHeightPct, xPos, yPos);
  }
}

function createTileElement(url, bgWidth, bgHeight, xPos, yPos) {
  const layer = document.createElement('div');
  layer.className = 'content-layer';

  const tileEl = document.createElement('div');
  tileEl.className = 'display-tile anim-fade-in';

  tileEl.style.backgroundSize = `${bgWidth}% ${bgHeight}%`;
  tileEl.style.backgroundPosition = `${xPos}% ${yPos}%`;
  tileEl.style.backgroundImage = `url('${url}')`;

  layer.appendChild(tileEl);
  document.getElementById('canvas').appendChild(layer);
}

let currentVideo = null;

function showVideo(msg) {
  hideIdle();
  // Remove any existing video first
  if (currentVideo) {
    currentVideo.pause();
    currentVideo.parentElement?.remove();
    currentVideo = null;
  }

  const layer = createLayer(msg.position);
  const video = document.createElement('video');
  video.className = 'display-video anim-fade-in';
  video.id = 'active-video';

  if (msg.fit === 'cover') video.classList.add('fit-cover');

  video.src = msg.url;
  video.loop = msg.loop !== false;
  video.muted = msg.muted !== false; // Muted by default for autoplay
  video.playsInline = true;
  video.preload = 'auto';

  video.onerror = () => {
    const errEl = document.createElement('div');
    errEl.className = 'display-text anim-fade-in';
    errEl.style.fontSize = '1rem';
    errEl.style.color = 'rgba(255,100,100,0.5)';
    errEl.textContent = '⚠ Video nicht ladbar';
    layer.appendChild(errEl);
  };

  video.oncanplay = () => {
    if (msg.autoplay !== false) {
      video.play().catch(e => {
        console.log('Autoplay blocked:', e);
        // Try muted autoplay as fallback
        video.muted = true;
        video.play().catch(() => {});
      });
    }
  };

  layer.appendChild(video);
  document.getElementById('canvas').appendChild(layer);
  currentVideo = video;
}

function controlVideo(msg) {
  const video = currentVideo || document.getElementById('active-video');
  if (!video) return;

  switch (msg.action) {
    case 'play':
      video.play().catch(() => {});
      break;
    case 'pause':
      video.pause();
      break;
    case 'stop':
      video.pause();
      video.currentTime = 0;
      break;
    case 'mute':
      video.muted = true;
      break;
    case 'unmute':
      video.muted = false;
      break;
    case 'seek':
      if (typeof msg.time === 'number') {
        video.currentTime = msg.time;
      }
      break;
    case 'sync':
      // Sync to a target time (for coordinated playback)
      if (typeof msg.time === 'number') {
        const diff = Math.abs(video.currentTime - msg.time);
        if (diff > 0.5) { // Only sync if drift is significant
          video.currentTime = msg.time;
        }
      }
      if (msg.playing && video.paused) {
        video.play().catch(() => {});
      } else if (!msg.playing && !video.paused) {
        video.pause();
      }
      break;
  }
}

function clearContent(style) {
  // Stop and clear any playing video
  if (currentVideo) {
    currentVideo.pause();
    currentVideo = null;
  }

  const layers = document.querySelectorAll('.content-layer');
  layers.forEach(layer => {
    layer.classList.add('anim-fade-out');
    setTimeout(() => layer.remove(), 1000);
  });
  setTimeout(() => {
    document.body.style.background = '#0a0a0a';
    showIdle();
  }, 1100);
}

function applyEffect(effect, duration) {
  const canvas = document.getElementById('canvas');
  canvas.classList.add(`effect-${effect}`);
  if (effect === 'flash') {
    document.body.classList.add('effect-flash');
    setTimeout(() => document.body.classList.remove('effect-flash'), duration);
  }
  setTimeout(() => canvas.classList.remove(`effect-${effect}`), duration);
}

// --- Helpers ---

function createLayer(position) {
  const layer = document.createElement('div');
  layer.className = 'content-layer';
  if (position && position !== 'center') {
    layer.classList.add(`pos-${position}`);
  }
  return layer;
}

function typewriterEffect(el, text, onComplete) {
  let i = 0;
  const speed = 50 + Math.random() * 30;
  function type() {
    if (i < text.length) {
      el.textContent += text.charAt(i);
      i++;
      setTimeout(type, speed + (Math.random() * 20 - 10));
    } else {
      if (onComplete) onComplete();
    }
  }
  type();
}

function hideIdle() {
  const idle = document.getElementById('idle-indicator');
  if (idle) idle.style.display = 'none';
}

function showIdle() {
  const idle = document.getElementById('idle-indicator');
  if (idle) idle.style.display = 'block';
}

// --- Eyeball System ---
let eyeballScene = null;
let eyeballCamera = null;
let eyeballRenderer = null;
let eyeballGroup = null;
let eyeballPupil = null;
let eyeballActive = false;
let targetGaze = { x: 0, y: 0 };
let currentGaze = { x: 0, y: 0 };
let displayConfig = {
  position: { x: 0, y: 0, z: 0 },
  rotation: 0 // facing direction in degrees (0 = toward audience)
};

function initEyeball() {
  if (eyeballScene) return; // Already initialized

  const container = document.getElementById('eyeball-container');

  // Scene
  eyeballScene = new THREE.Scene();
  eyeballScene.background = new THREE.Color(0x0a0a0a);

  // Camera
  eyeballCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
  eyeballCamera.position.z = 3;

  // Renderer
  eyeballRenderer = new THREE.WebGLRenderer({ antialias: true });
  eyeballRenderer.setSize(window.innerWidth, window.innerHeight);
  eyeballRenderer.setPixelRatio(window.devicePixelRatio);
  container.appendChild(eyeballRenderer.domElement);

  // Eyeball group (for rotation)
  eyeballGroup = new THREE.Group();
  eyeballScene.add(eyeballGroup);

  // Main eyeball (sclera)
  const scleraGeometry = new THREE.SphereGeometry(1, 64, 64);
  const scleraMaterial = new THREE.MeshPhongMaterial({
    color: 0xf5f5f0,
    shininess: 30
  });
  const sclera = new THREE.Mesh(scleraGeometry, scleraMaterial);
  eyeballGroup.add(sclera);

  // Iris
  const irisGeometry = new THREE.SphereGeometry(0.45, 32, 32);
  const irisMaterial = new THREE.MeshPhongMaterial({
    color: 0x4a7c59, // Green-ish iris
    shininess: 50
  });
  const iris = new THREE.Mesh(irisGeometry, irisMaterial);
  iris.position.z = 0.88;
  iris.scale.z = 0.3;
  eyeballGroup.add(iris);

  // Pupil
  const pupilGeometry = new THREE.SphereGeometry(0.2, 32, 32);
  const pupilMaterial = new THREE.MeshPhongMaterial({
    color: 0x000000,
    shininess: 100
  });
  eyeballPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
  eyeballPupil.position.z = 0.98;
  eyeballPupil.scale.z = 0.2;
  eyeballGroup.add(eyeballPupil);

  // Cornea (transparent layer)
  const corneaGeometry = new THREE.SphereGeometry(1.02, 64, 64);
  const corneaMaterial = new THREE.MeshPhongMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.1,
    shininess: 100
  });
  const cornea = new THREE.Mesh(corneaGeometry, corneaMaterial);
  eyeballGroup.add(cornea);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
  eyeballScene.add(ambientLight);

  const mainLight = new THREE.DirectionalLight(0xffffff, 1);
  mainLight.position.set(2, 2, 5);
  eyeballScene.add(mainLight);

  const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
  fillLight.position.set(-2, -1, 3);
  eyeballScene.add(fillLight);

  // Add subtle red veins (optional detail)
  addVeins();

  // Handle resize
  window.addEventListener('resize', onEyeballResize);

  // Start animation loop
  animateEyeball();
}

function addVeins() {
  const veinMaterial = new THREE.LineBasicMaterial({
    color: 0xcc6666,
    transparent: true,
    opacity: 0.3
  });

  for (let i = 0; i < 8; i++) {
    const points = [];
    const angle = (i / 8) * Math.PI * 2;
    const startRadius = 0.7;

    // Create branching vein
    let x = Math.cos(angle) * startRadius;
    let y = Math.sin(angle) * startRadius;
    let z = Math.sqrt(1 - x*x - y*y) * 0.95;

    points.push(new THREE.Vector3(x, y, z));

    for (let j = 0; j < 3; j++) {
      const r = startRadius + (j + 1) * 0.08;
      const wiggle = (Math.random() - 0.5) * 0.1;
      x = Math.cos(angle + wiggle) * r;
      y = Math.sin(angle + wiggle) * r;
      z = Math.sqrt(Math.max(0, 1 - x*x - y*y)) * 0.95;
      points.push(new THREE.Vector3(x, y, z));
    }

    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const vein = new THREE.Line(geometry, veinMaterial);
    eyeballGroup.add(vein);
  }
}

function onEyeballResize() {
  if (!eyeballCamera || !eyeballRenderer) return;
  eyeballCamera.aspect = window.innerWidth / window.innerHeight;
  eyeballCamera.updateProjectionMatrix();
  eyeballRenderer.setSize(window.innerWidth, window.innerHeight);
}

function animateEyeball() {
  if (!eyeballActive) {
    requestAnimationFrame(animateEyeball);
    return;
  }

  requestAnimationFrame(animateEyeball);

  // Smooth interpolation toward target gaze
  const smoothing = 0.08;
  currentGaze.x += (targetGaze.x - currentGaze.x) * smoothing;
  currentGaze.y += (targetGaze.y - currentGaze.y) * smoothing;

  // Add subtle organic movement
  const time = Date.now() * 0.001;
  const microX = Math.sin(time * 1.5) * 0.01;
  const microY = Math.cos(time * 1.3) * 0.01;

  // Apply rotation to eyeball group
  // Limit rotation to realistic eye movement range (~30 degrees)
  const maxRotation = 0.5; // radians
  eyeballGroup.rotation.y = Math.max(-maxRotation, Math.min(maxRotation, currentGaze.x + microX));
  eyeballGroup.rotation.x = Math.max(-maxRotation, Math.min(maxRotation, -(currentGaze.y + microY)));

  eyeballRenderer.render(eyeballScene, eyeballCamera);
}

function showEyeball(msg) {
  hideIdle();
  clearContent('instant');

  // Apply color if specified
  if (msg.irisColor) {
    // Will be applied after init
  }

  initEyeball();

  const container = document.getElementById('eyeball-container');
  container.classList.add('active');
  eyeballActive = true;

  // Apply custom iris color if specified
  if (msg.irisColor && eyeballGroup) {
    const iris = eyeballGroup.children[1];
    if (iris && iris.material) {
      iris.material.color.setStyle(msg.irisColor);
    }
  }

  // Apply background color
  if (msg.bgColor && eyeballScene) {
    eyeballScene.background = new THREE.Color(msg.bgColor);
  }
}

function hideEyeball() {
  const container = document.getElementById('eyeball-container');
  container.classList.remove('active');
  eyeballActive = false;
  showIdle();
}

function updateEyeballGaze(msg) {
  if (!eyeballActive) return;

  // msg contains face position in world/room coordinates
  const facePos = { x: msg.x || 0, y: msg.y || 0, z: msg.z || 5 };

  // Calculate gaze direction from this display's position to face
  const dx = facePos.x - displayConfig.position.x;
  const dy = facePos.y - displayConfig.position.y;
  const dz = facePos.z - displayConfig.position.z;

  // Apply display rotation
  const rotRad = displayConfig.rotation * Math.PI / 180;
  const rotatedX = dx * Math.cos(rotRad) - dz * Math.sin(rotRad);
  const rotatedZ = dx * Math.sin(rotRad) + dz * Math.cos(rotRad);

  // Convert to normalized gaze (-1 to 1)
  const distance = Math.sqrt(rotatedX * rotatedX + rotatedZ * rotatedZ);
  if (distance > 0.1) {
    targetGaze.x = Math.max(-1, Math.min(1, rotatedX / distance));
    targetGaze.y = Math.max(-1, Math.min(1, dy / Math.max(1, distance)));
  }
}

function configureDisplay(msg) {
  if (msg.position) {
    displayConfig.position = msg.position;
  }
  if (typeof msg.rotation === 'number') {
    displayConfig.rotation = msg.rotation;
  }
  console.log('Display configured:', displayConfig);
}

// --- Wake Lock (prevent screen sleep) ---
let wakeLock = null;
let noSleepVideo = null;

async function requestWakeLock() {
  // Try modern Wake Lock API first
  if ('wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake Lock active');
      wakeLock.addEventListener('release', () => {
        console.log('Wake Lock released');
        wakeLock = null;
      });
      return;
    } catch (err) {
      console.log('Wake Lock failed:', err.message);
    }
  }

  // Fallback: silent video loop (works on older Android/Chrome)
  if (!noSleepVideo) {
    noSleepVideo = document.createElement('video');
    noSleepVideo.setAttribute('playsinline', '');
    noSleepVideo.setAttribute('webkit-playsinline', '');
    noSleepVideo.style.position = 'fixed';
    noSleepVideo.style.top = '-1px';
    noSleepVideo.style.left = '-1px';
    noSleepVideo.style.width = '1px';
    noSleepVideo.style.height = '1px';
    noSleepVideo.style.opacity = '0.01';
    // Tiny silent webm video (base64)
    noSleepVideo.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwH/////////FUmpZpkq17GDD0JATYCGQ2hyb21lV0WcQ0FOU0GWQB9DtnVBXueBAXPFgQGcgQAAgQBiZIEgY6KBACCqg4EBI0CYb8IAAABUSOn5OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAADIq17GDD0JATYCGQ2hyb21lV0WcQ0FOU0GWQB9DtnVBXueBAXPFgQGcgQAAgQBiZIEgY6KBACCBB0FMsAEAAAAAAAAMq4F3RQAAAAAAZAAAAA==';
    noSleepVideo.loop = true;
    noSleepVideo.muted = true;
    document.body.appendChild(noSleepVideo);
  }
  noSleepVideo.play().then(() => {
    console.log('Wake Lock active (video fallback)');
  }).catch(err => {
    console.log('Video wake lock failed:', err.message);
  });
}

// Re-acquire wake lock when tab becomes visible again
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    if (!wakeLock && !noSleepVideo) requestWakeLock();
    else if (noSleepVideo && noSleepVideo.paused) noSleepVideo.play().catch(() => {});
  }
});

// --- Start ---
connect();
requestWakeLock();

// Heartbeat to keep WebSocket alive
setInterval(() => {
  if (ws && ws.readyState === 1) {
    ws.send(JSON.stringify({ type: 'heartbeat' }));
  }
}, 30000);
</script>
</body>
</html>
